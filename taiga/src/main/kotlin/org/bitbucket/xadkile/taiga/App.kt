package org.bitbucket.xadkile.taiga

import org.zeromq.SocketType
import org.zeromq.ZContext
import java.io.BufferedReader
import java.io.File
import java.io.InputStream
import java.io.InputStreamReader
import java.util.*
import java.util.concurrent.Executors
import java.util.function.Consumer

internal class StreamGobbler(private val inputStream: InputStream, private val consumer: Consumer<String>) :
    Runnable {
    override fun run() {
        BufferedReader(InputStreamReader(inputStream)).lines()
            .forEach(consumer)
    }
}

/**
 * run a piece of python code to start a kernel
 * [pythonExePath] should be obtain externally (from UI or something)
 * connection info can be extract from stdio
 * DONT PORT THIS TO JAVA, IT'S STUPID, JUST USE JUPYTER CLIENT
 */
fun startKernel(pythonExePath: String): Process {
    val code = "import jupyter_client\n" +
            "kernelMan =jupyter_client.KernelManager()\n" +
            "kernelMan.start_kernel()"
    val processBuilder = ProcessBuilder(pythonExePath, "-c", code)
    val rt = processBuilder.inheritIO().start()
    return rt
}

/*
    {
  "shell_port": 38961,
  "iopub_port": 38171,
  "stdin_port": 58259,
  "control_port": 41889,
  "hb_port": 53571,
  "ip": "127.0.0.1",
  "key": "2945bcae-853fc65ca847550a65f75ce5",
  "transport": "tcp",
  "signature_scheme": "hmac-sha256",
  "kernel_name": ""
     */
fun main() {
    ZContext().use { context ->

        /*
        [
          b'u-u-i-d',         # zmq identity(ies) => identity can be auto generated by zmq or specificied by me use ZMQ.Socket.setIdentity
          b'<IDS|MSG>',       # delimiter => is is a must
          b'baddad42',        # HMAC signature
          b'{header}',        # serialized header dict
          b'{parent_header}', # serialized parent header dict
          b'{metadata}',      # serialized metadata dict
          b'{content}',       # serialized content dict
          b'\xf0\x9f\x90\xb1' # extra raw data buffer(s)
          ...
        ]
         */

        // TODO convert request input into zmq compatible message: an array of some byte blob
        // make: HMAC generator because I need it to generate a HMAC signature
        // get each element
        // what is serialized? JSON -> byte array ???
//        val python = "/home/abc/Applications/anaconda3/envs/dl_hw_01/bin/python"
//        startKernel(python)
        val socket = context.createSocket(SocketType.DEALER)
        val port = 35105
        socket.connect("tcp://localhost:$port")
        socket.sendMore("<IDS|MSG>".toByteArray(Charsets.UTF_8))
        val clientSessionId = "c9c22b3d-c6a2-4ec8-917d-fd201e906b6c"
        println(clientSessionId)
        val messageHeader = MessageHeader(
            msg_id=UUID.randomUUID().toString(),
            session=clientSessionId,
            username = "abc",
            data = "",
            msg_type = "shutdown_request",
        )
        val request = Request(
            header = messageHeader,
            parent_header = null,
            content = Content()
        )
    }
}

fun processBuilder() {
    val envBinDir = "/home/abc/Applications/anaconda3/envs/dl_hw_01/bin"
    val builder = ProcessBuilder()
    val l = listOf(
        "/home/abc/Applications/anaconda3/envs/dl_hw_01/bin/python",
        "-m",
        "ipykernel_launcher",
        "-f",
        "/tmp/tmpwmp8kgkt.json"
    )
    builder.command(l)
    builder.redirectErrorStream(true)
    builder.directory(File(System.getProperty("user.home")))
    val process = builder.start()
    val streamGobbler: StreamGobbler = StreamGobbler(process.inputStream,
        Consumer { x: String? -> println(x) })
    Executors.newSingleThreadExecutor().submit(streamGobbler)
    val exitCode = process.waitFor()
    assert(exitCode == 0)
}

data class MessageHeader(
    val msg_id: String = "",
    val session: String = "",
    val username: String = "",
    val data: String = "", //ISO 8601
    val msg_type: String = "",
    val version: String = "5.0"
)

data class Content(val restart: Boolean = false)
data class Request(
    val header: MessageHeader = MessageHeader(),
    val parent_header: MessageHeader? = null,
    val metadata: Any = object {},
    val content: Any = object {},
    val buffers: List<Any> = emptyList()
)

class HMACMaker{

}
